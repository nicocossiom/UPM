<html data-darkreader-mode="dynamic" data-darkreader-scheme="dark">

<head>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <style class="darkreader darkreader--fallback" media="screen"></style>
  <style class="darkreader darkreader--text" media="screen"></style>
  <style class="darkreader darkreader--invert" media="screen">
    .jfk-bubble.gtx-bubble,
    .captcheck_answer_label>input+img,
    span#closed_text>img[src^="https://www.gstatic.com/images/branding/googlelogo"],
    span[data-href^="https://www.hcaptcha.com/"]>#icon,
    #bit-notification-bar-iframe,
    ::-webkit-calendar-picker-indicator {
      filter: invert(100%) hue-rotate(180deg) contrast(90%) !important;
    }
  </style>
  <style>
    body {
      margin: 60px;
      max-width: fit-content;
    }
  </style>
  <style class="darkreader darkreader--inline" media="screen">
    [data-darkreader-inline-bgcolor] {
      background-color: var(--darkreader-inline-bgcolor) !important;
    }

    [data-darkreader-inline-bgimage] {
      background-image: var(--darkreader-inline-bgimage) !important;
    }

    [data-darkreader-inline-border] {
      border-color: var(--darkreader-inline-border) !important;
    }

    [data-darkreader-inline-border-bottom] {
      border-bottom-color: var(--darkreader-inline-border-bottom) !important;
    }

    [data-darkreader-inline-border-left] {
      border-left-color: var(--darkreader-inline-border-left) !important;
    }

    [data-darkreader-inline-border-right] {
      border-right-color: var(--darkreader-inline-border-right) !important;
    }

    [data-darkreader-inline-border-top] {
      border-top-color: var(--darkreader-inline-border-top) !important;
    }

    [data-darkreader-inline-boxshadow] {
      box-shadow: var(--darkreader-inline-boxshadow) !important;
    }

    [data-darkreader-inline-color] {
      color: var(--darkreader-inline-color) !important;
    }

    [data-darkreader-inline-fill] {
      fill: var(--darkreader-inline-fill) !important;
    }

    [data-darkreader-inline-stroke] {
      stroke: var(--darkreader-inline-stroke) !important;
    }

    [data-darkreader-inline-outline] {
      outline-color: var(--darkreader-inline-outline) !important;
    }

    [data-darkreader-inline-stopcolor] {
      stop-color: var(--darkreader-inline-stopcolor) !important;
    }
  </style>
  <style class="darkreader darkreader--variables" media="screen">
    :root {
      --darkreader-neutral-background: #131516;
      --darkreader-neutral-text: #d8d4cf;
      --darkreader-selection-background: #004daa;
      --darkreader-selection-text: #e8e6e3;
    }
  </style>
  <style class="darkreader darkreader--root-vars" media="screen"></style>
  <style class="darkreader darkreader--user-agent" media="screen">
    html {
      background-color: #181a1b !important;
    }

    html {
      color-scheme: dark !important;
    }

    html,
    body {
      background-color: #181a1b;
    }

    html,
    body {
      border-color: #736b5e;
      color: #e8e6e3;
    }

    a {
      color: #3391ff;
    }

    table {
      border-color: #545b5e;
    }

    ::placeholder {
      color: #b2aba1;
    }

    input:-webkit-autofill,
    textarea:-webkit-autofill,
    select:-webkit-autofill {
      background-color: #404400 !important;
      color: #e8e6e3 !important;
    }

    ::selection {
      background-color: #004daa !important;
      color: #e8e6e3 !important;
    }

    ::-moz-selection {
      background-color: #004daa !important;
      color: #e8e6e3 !important;
    }
  </style>
  <meta charset="UTF-8">
  <title>Proyecto de administración de sistemas informáticos</title>
  <meta name="darkreader" content="b5693943e5cd42c2abde4cd1e2e08d7a">
  <style class="darkreader darkreader--override" media="screen">
    .vimvixen-hint {
      background-color: #7b5300 !important;
      border-color: #d8b013 !important;
      color: #f3e8c8 !important;
    }

    ::placeholder {
      opacity: 0.5 !important;
    }

    #edge-translate-panel-body,
    .MuiTypography-body1,
    .nfe-quote-text {
      color: var(--darkreader-neutral-text) !important;
    }

    gr-main-header {
      background-color: #0f3a48 !important;
    }

    .tou-z65h9k,
    .tou-mignzq,
    .tou-1b6i2ox,
    .tou-lnqlqk {
      background-color: var(--darkreader-neutral-background) !important;
    }

    .tou-75mvi {
      background-color: #032029 !important;
    }

    .tou-ta9e87,
    .tou-1w3fhi0,
    .tou-1b8t2us,
    .tou-py7lfi,
    .tou-1lpmd9d,
    .tou-1frrtv8,
    .tou-17ezmgn {
      background-color: #0a0a0a !important;
    }

    .tou-uknfeu {
      background-color: #231603 !important;
    }

    .tou-6i3zyv {
      background-color: #19576c !important;
    }

    embed[type="application/pdf"] {
      filter: invert(100%) contrast(90%);
    }
  </style>
</head>

<body>
  <h1>Proyecto de administración de sistemas informáticos</h1>
  <h2>Objetivos</h2>
  El objetivo de este proyecto práctico de desarrollo en pareja, aunque
  también puede realizarse de forma individual, es revisar de forma
  aplicada algunos de los conceptos estudiados en la parte teórica de la
  asignatura, concretamente, en la parte de administración de sistemas
  Linux, tales como:
  <ul>
    <li>La gestión de usuarios y grupos, así como de los permisos de acceso de estos a los recursos.
    </li>
    <li>La gestión de paquetes.
    </li>
    <li>La administración de los dispositivos de almacenamiento,
      incluyendo la gestión de volúmenes, la creación de sistemas de ficheros y
      las operaciones de montaje.
    </li>
    <li>La administración de un servicio de red, concretamente, NFS.
    </li>
    <li>Los fundamentos de las técnicas usadas para automatizar la administración.
    </li>
    <li>La programación de <i>scripts</i>.
    </li>
  </ul>
  <h2>Planteamiento general</h2>
  El proyecto consiste en el desarrollo de <i>scripts</i> de administración, uno por cada una de las siguientes 5 fases
  de las que consta el proyecto:
  <ol>
    <li><tt>crear_usuarios</tt>: gestión de usuarios.
    </li>
    <li><tt>configurar_almacenamiento</tt>: administración de volúmenes.
    </li>
    <li><tt>nfs_servidor</tt>: configuración de la parte servidora de NFS.
    </li>
    <li><tt>nfs_cliente</tt>: configuración de la parte cliente de NFS.
    </li>
    <li><tt>maestro</tt>: automatización de la administración de máquinas remotas, ejecutando de forma remota los
      <i>scripts</i> desarrollados en las fases previas (un Ansible de <i>andar por casa</i>).
    </li>
  </ol>
  Cada fase se <b>calificará con 2 puntos</b> y pueden realizarse <b>en cualquier orden</b>
  (de hecho, incluso se podría realizar la última fase antes de las
  demás, como se verá en el enunciado de la misma), exceptuando las fases
  vinculadas con NFS que deberían realizarse en el orden indicado (no se
  tendrá en cuenta una entrega de la cuarta fase si no se hace también una
  de la tercera). Así, por ejemplo, se podrían entregar solo los tres
  últimos <i>scripts</i>, pudiendo llegar a obtener una calificación de 6 puntos.
  <p>Nótese que los 3 primeros <i>scripts</i> se pueden desarrollar en un
    único equipo, mientras que para los 2 últimos sería conveniente disponer
    de, al menos, dos equipos.

  </p>
  <h2>Plataforma de desarrollo</h2>
  La distribución de Linux seleccionada para la práctica es Ubuntu 22.04.
  Si se plantea desarrollarla en otra distribución, puede hacerlo, pero
  debería probar el código desarrollado en la distribución seleccionada ya
  que será la usada para evaluar la práctica.
  <p>
    Para el desarrollo de la práctica puede usar máquinas reales o virtuales
    usando, por ejemplo, Virtualbox. En ese último caso, puede optar por
    gestionar manualmente las máquinas virtuales o usar una herramienta como
    Vagrant para administrarlas de una manera más automática.
  </p>
  <p>
    Para poder probar el segundo <i>script</i>, el equipo debería disponer
    de varios discos, aunque bastaría con varias particiones libres. En el
    caso de usar una máquina virtual, estando esta parada, puede añadirle
    nuevos discos.
  </p>
  <p>
    Con respecto a las dos últimas fases, convendría probarlas en, al menos,
    2 equipos. Si usa un entorno de virtualización, puede instalar Ubuntu
    22.04 en un equipo y luego clonarlo, estableciendo una conectividad que
    permita a esos equipos comunicarse entre sí y salir a Internet (téngase
    en cuenta que los <i>scripts</i> deben instalar paquetes).
  </p>
  <p>
    En el caso de Virtualbox, para ahorrar el gasto de disco, puede usar una clonación enlazada especificando en la
    <i>política de dirección de MAC</i>
    la opción de generar nuevas direcciones MAC para todas las interfaces.
    En cuanto a la conectividad, se recomienda configurar la interfaz de red
    con la modalidad <i>red NAT</i>, que cumple los requisitos de conectividad especificados previamente.

  </p>
  <h2>Consideraciones generales sobre la programación de los <i>scripts</i></h2>
  A continuación, se exponen algunas pautas sobre la programación de los <i>scripts</i> planteados en este proyecto
  práctico:
  <ul>
    <li>No deben ser interactivos: no pueden quedarse a la espera de alguna entrada de teclado.
    </li>
    <li>Solo deben escribir por la salida estándar lo especificado en
      el enunciado, aunque sí se puede usar la salida de error a discreción.
    </li>
    <li>Deben instalar todos los paquetes que se requieran. Se asumirá
      que ya están instalados aquellos que aparecen como tal en una
      instalación por defecto de Ubuntu 22.04.
    </li>
    <li>No realizarán la operación <tt>apt update</tt>.
    </li>
    <li>Para evitar desconfigurar la máquina de pruebas debido a un
      error de programación, la funcionalidad que se plantea no incluye
      operaciones <i>destructivas</i> tales como borrar ficheros, eliminar usuarios o grupos, desinstalar paquetes o
      borrar volúmenes.
    </li>
    <li>Con respecto a la gestión de errores en los <i>scripts</i> que
      se resuelven de forma local (los tres primeros), se ha optado por un
      tratamiento por anticipado: antes de realizar las operaciones para las
      que está concebido, el <i>script</i> deberá comprobar <i>a priori</i>
      todas las condiciones de error, no realizando ninguna labor si falla esa
      comprobación. Esta técnica reduce la posibilidad de que se produzcan
      errores durante la ejecución del <i>script</i>. Téngase en cuenta que, sin esa comprobación <i>a priori</i>,
      esos errores en medio de la operación normalmente requerirán deshacer
      algunas de las acciones realizadas previamente para evitar que el
      sistema se quede en un estado inconsistente (en la primera fase, por
      ejemplo, si el tercer usuario que se quiere crear ya existe, habría que
      abortar la operación pero eliminando antes el grupo y los dos usuarios
      previamente creados). Eso es precisamente lo que se pretendía evitar en
      el punto anterior.
    </li>
    <li>En cualquier caso, aunque sea poco probable, alguna de la
      condiciones comprobadas podría dejar de cumplirse en el pequeño
      intervalo de tiempo que transcurre desde que se comprueba hasta que se
      realiza la operación asociada, produciéndose un error (con mala suerte,
      en el ejemplo, justo después de comprobar que no había ningún usuario
      repetido, alguien crea un usuario duplicado). En ese caso, para
      simplificar la práctica, bastará con terminar el <i>script</i> con el valor de retorno que considere oportuno, ya
      que esa funcionalidad de tratamiento de errores <i>sobrevenidos</i>
      no se probará en la evaluación de la práctica, no siendo necesario
      deshacer el trabajo ya realizado, aunque esto pueda dejar el sistema en
      un estado incoherente.
    </li>
    <li>Con respecto al tratamiento de errores en los dos últimos <i>scripts</i>, dado que su funcionamiento depende de
      otros nodos, en la sección dedicada a cada uno se explicará cómo se debe proceder.
    </li>
  </ul>

  <h2>Consideraciones generales sobre la ejecución de los <i>scripts</i></h2>
  A continuación, se expresan algunas pautas sobre la ejecución de los <i>scripts</i>:
  <ul>
    <li>Al no permitirse la ejecución interactiva, la ejecución de los <i>scripts</i> no debe requerir ningún tipo de
      contraseña.
    </li>
    <li>Se ejecutarán en la cuenta del usuario creado por defecto en la instalación de la distribución: los 4 primeros
      <i>scripts</i> usando <tt>sudo</tt>. Se asume, por tanto, que ese usuario pertenecerá al grupo que permite
      ejecutar <tt>sudo</tt>.
    </li>
    <li>Se configurará el fichero <tt>/etc/sudoers</tt> para que no requiera contraseña (esa labor no se hace dentro del
      <i>script</i>
      sino manualmente antes de empezar a desarrollar la práctica). En Ubuntu
      22.04, habría que realizar las siguientes modificaciones en el fichero:
      <pre># Allow members of group sudo to execute any command
#%sudo  ALL=(ALL:ALL) ALL            # comentar esta línea
%sudo   ALL=(ALL:ALL) NOPASSWD:ALL   # y añadir esta
</pre>
    </li>
    <li>En el caso del último <i>script</i>, se asume que en todas las máquinas el usuario por defecto tiene el mismo
      nombre y está habilitado para <tt>sudo</tt> sin contraseña.
    </li>
    <li>Dado que este último <i>script</i> se basa en el uso de <tt>ssh</tt>
      y, además, no se permite la ejecución interactiva, hay que asegurarse
      de que está instalado en todas las máquinas usando un modo de operación
      sin contraseñas (esa labor no se hace dentro del <i>script</i> sino manualmente antes de empezar a desarrollar la
      quinta fase). Para ello, puede ejecutar la siguiente secuencia:
      <pre>ssh-keygen # generar las claves dejando vacía la passphrase
ssh-copy-id 10.0.2.4 # copiar las claves a la máquina remota usando la contraseña
</pre>
    </li>
    <li>Este último <i>script</i> se ejecutará sin <tt>sudo</tt>, pero sí lo usará internamente en la ejecución de los
      <i>scripts</i> remotos, tal como se explicará cuando se presente la última fase.
    </li>
  </ul>

  <h2>Primera fase</h2>
  Se pretende crear las cuentas de un conjunto de usuarios relacionados
  entre sí (por ejemplo, porque participan en un mismo proyecto). Para
  facilitar la compartición de ficheros entre ellos, se creará un grupo de
  usuarios al que todos pertenecerán como grupo secundario o
  suplementario (es decir, cada usuario tendrá como grupo primario el
  creado por defecto con el mismo nombre que el usuario, pero, además
  estará asociado a ese grupo secundario). Asimismo, se creará un
  directorio en <tt>/srv</tt> con el nombre de ese grupo secundario donde se almacenarán los ficheros que quieran
  compartir.
  <p>
    El formato del mandato es el siguiente:
  </p>
  <pre>crear_usuarios grupo usuario1 usuario2...
</pre>
  En caso de funcionamiento correcto, el <i>script</i> debe imprimir por la salida estándar las contraseñas asociadas a
  las cuentas de usuario creadas con el siguiente formato:
  <pre>usuario1:contraseña
usuario2:contraseña
...................
</pre>
  La funcionalidad del <i>script</i> es:
  <ul>
    <li>Como se explicó previamente, se debe realizar un control de errores
      antes de realizar ninguna operación. En ese control se deben verificar
      las siguientes condiciones de error que provocarán que el <i>script</i> termine inmediatamente retornando un
      código de error:
      <ul>
        <li>Se debe estar ejecutando como superusuario (recuerde que, como se indicó previamente, se debe ejecutar con
          <tt>sudo</tt>), devolviendo un 1 en caso contrario. Esa comprobación ya está incluida en el <i>script</i>
          proporcionado como material de apoyo.
        </li>
        <li>El número de argumentos debe de ser correcto, devolviendo un 2 en caso contrario.
        </li>
        <li>No debe existir un fichero o directorio <tt>/srv/grupo</tt>, devolviendo un 3 en caso contrario.
        </li>
        <li>No debe existir ese grupo, devolviendo un 4 en caso contrario.
          Hay distintas formas de comprobarlo. Una posibilidad es el uso del
          mandato <tt>getent</tt>.
        </li>
        <li>No debe existir ninguno de los usuarios especificados,
          devolviendo un 5 en caso contrario. Hay distintas formas de comprobarlo.
          Una posibilidad es el uso del mandato <tt>getent</tt>.
        </li>
      </ul>
    </li>
    <li>Una vez verificada la falta de errores, se procederá con las operaciones asociadas a este <i>script</i>:
      <ul>
        <li>Creación del grupo secundario. Puede usar el mandato <tt>groupadd</tt> ya que está disponible en todas las
          distribuciones.
        </li>
        <li>Creación de los usuarios indicados. Puede usar el mandato <tt>useradd</tt> especificando que el <i>shell</i>
          sea el <tt>bash</tt>, que se cree el directorio <tt>home</tt> e incluyéndolo en el grupo secundario indicado.
        </li>
        <li>Con respecto a la gestión de la contraseña, debe tener en cuenta (por defecto, <tt>useradd</tt> crea una
          cuenta bloqueada):
          <ul>
            <li>Se debe generar una aleatoria para cada usuario. Hay numerosas formas de generar una cadena de
              caracteres aleatoria (<a href="https://linuxhint.com/generate-random-password-linux/">aquí hay varios
                ejemplos</a>). Recuerde que, si opta por un mandato que no está instalado en Ubuntu 22.04, deberá
              proceder con la instalación.
            </li>
            <li>Una vez obtenida, además de imprimirla por la salida estándar
              junto con el nombre del usuario separados por el carácter dos puntos,
              debe asociarla con el usuario. Una forma posible de hacerlo es mediante
              el mandato <tt>chpasswd</tt>. También puede hacerlo en el propio mandato <tt>useradd</tt> con la opción
              <tt>-p</tt>, pero tenga en cuenta que en ese caso la contraseña debe estar ya cifrada.
            </li>
            <li>Aunque no se evaluará estrictamente este aspecto, un reto que se presenta en la realización de un
              <i>script</i> que gestione contraseñas es cómo asegurarse de que las contraseñas no son visibles de alguna
              forma mientras se ejecuta el <i>script</i>. Así, por ejemplo, si la contraseña aparece como argumento de
              un mandato, el usuario <i>maligno</i> podría tener acceso a la misma haciendo un <tt>ps</tt> justo en el
              momento que se ejecuta el mandato, a no ser que se trate de un mandato interno del <i>shell</i> como, por
              ejemplo, <tt>echo</tt>.
            </li>
          </ul>
        </li>
        <li>Hay que crear el directorio asociado al grupo de usuarios (<tt>/srv/grupo</tt>), que deberá tener las
          siguientes características:
          <ul>
            <li>El dueño será el primer usuario y estará asociado al grupo secundario indicado.
            </li>
            <li>Permitirá acceso y lectura a todos los usuarios, pero solo
              podrán crear y borrar entradas el dueño y los usuarios asociados al
              grupo secundario especificado.
            </li>
            <li>El directorio será configurado de manera que todos los ficheros
              que se creen en el mismo estén asociados automáticamente con el grupo
              secundario y no con el grupo del usuario que crea el fichero,
              facilitando la compartición, como se verá en el ejemplo que se muestra
              acto seguido. Una pista sobre esta funcionalidad: revise todas las
              aplicaciones de los bits SETUID/SETGID.
            </li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
  A continuación, se muestra un ejemplo de la ejecución de este mandato ilustrando cuál debe ser su comportamiento:
  <pre>fperez@ubuntu22:~/ASI/proyecto$ sudo ./crear_usuarios.sh proyectoX usu1 usu2 usu3
usu1:ijdyhing
usu2:deadWokPi
usu3:vemNeicNub
fperez@ubuntu22:~/ASI/proyecto$ ls /srv
proyectoX
fperez@ubuntu22:~/ASI/proyecto$ su - usu2
Contraseña: 
usu2@ubuntu22:~$ echo hola &gt; /srv/proyectoX/fichero
usu2@ubuntu22:~$ ls -l /srv/proyectoX/fichero # pertenece al grupo proyecto X, no al grupo usu2 
-rw-rw-r-- 1 usu2 proyectoX 5 nov 11 06:16 /srv/proyectoX/fichero
usu2@ubuntu22:~$ su - usu3
Contraseña: 
usu3@ubuntu22:~$ echo adios &gt;&gt; /srv/proyectoX/fichero
usu3@ubuntu22:~$ su - fperez
Contraseña: 
fperez@ubuntu22:~$ echo buenas &gt;&gt; /srv/proyectoX/fichero
-bash: /srv/proyectoX/fichero: Permiso denegado
fperez@ubuntu22:~$ cat /srv/proyectoX/fichero
hola
adios
</pre>

  <h2>Segunda fase</h2>
  El objetivo de esta fase es crear un espacio de almacenamiento flexible
  basado en volúmenes que podría ser usado como soporte por una
  herramienta o por un grupo de usuarios. Para ello, se creará un grupo de
  volúmenes (VG) sobre una colección de discos o particiones (PVs),
  generando el conjunto de volúmenes lógicos (LVs) solicitado que se
  montarán en los directorios indicados, los cuales se crearán si no
  existen
  <p>
    El formato del mandato es un poco complicado ya que, además del nombre
    del grupo de volúmenes, recibe como parámetros la colección de discos o
    particiones que se tomarán como base del grupo de volúmenes y el
    conjunto de directorios sobre los que se montarán los volúmenes lógicos
    pedidos, así como el porcentaje del total que ocupará cada volumen
    lógico.
  </p>
  <pre>configurar_almacenamiento.sh nombreVG num_discos disco1 disco2... num_LVs porcentaje1 directorio_montaje1 porcentaje2 directorio_montaje2...
</pre>
  El <i>script</i> no debe escribir nada por la salida estándar.
  <p>
    La funcionalidad del <i>script</i> es la siguiente:
  </p>
  <ul>
    <li>Como se explicó previamente, se debe realizar un control de errores
      antes de realizar ninguna operación. En ese control se deben verificar
      las siguientes condiciones de error que provocarán que el <i>script</i> termine inmediatamente retornando un
      código de error:
      <ul>
        <li>Se debe estar ejecutando como superusuario (recuerde que, como se indicó previamente, se debe ejecutar con
          <tt>sudo</tt>), devolviendo un 1 en caso contrario. Esa comprobación ya está incluida en el <i>script</i>
          proporcionado como material de apoyo.
        </li>
        <li>El número de argumentos debe de ser correcto y deben ser
          numéricos los argumentos correspondientes al número de
          discos/particiones, al número de LVs y a los porcentajes que indican el
          tamaño de cada LV, devolviendo un 2 en caso contrario. Dada la
          laboriosidad de esta comprobación ya está incluida en el <i>script</i> proporcionado como material de apoyo.
        </li>
        <li>Los porcentajes no pueden sumar más de 100, retornando un error
          con valor 3 en caso contrario. Esta funcionalidad ya aparece en el <i>script</i> dado como material de apoyo.
        </li>
        <li>Se debe comprobar que los discos/particiones recibidos como
          argumentos corresponden realmente a dispositivos de bloques, devolviendo
          un 4 en caso contrario. Una posible forma de comprobarlo es usar el
          mandato <tt>lsblk</tt>.
        </li>
        <li>Hay que asegurarse de que los directorios de montaje o bien no
          existen, en cuyo caso habrá que crearlos más adelante, o bien existen y
          son directorios, devolviendo un 5 en caso contrario.
        </li>
        <li>La última comprobación es que el grupo de volúmenes (VG)
          especificado no exista previamente, retornando un 7 en caso contrario.
          Para poder comprobarlo, es necesario tener instalado previamente el
          paquete con la funcionalidad de gestión de volúmenes (<tt>lvm2</tt>).
        </li>
      </ul>
    </li>
    <li>Una vez comprobado que no existen errores <i>a priori</i>, se procede a implementar la funcionalidad del
      <i>script</i>:
      <ul>
        <li>Se debe crear el VG que englobe todos los dispositivos involucrados. Recuerde que el mandato requerido
          (<tt>vgcreate</tt>) crea automáticamente los volúmenes físicos PVs, no siendo necesario realizar los
          respectivos <tt>pvcreate</tt>.
        </li>
        <li>Por cada LV, se deben realizar las siguientes operaciones:
          <ul>
            <li>Crear el directorio de montaje indicado en caso de que no exista.
            </li>
            <li>Crear el volumen lógico con el tamaño especificado. No es
              necesario darle un nombre explícito al LV. En caso de no hacerlo,
              obtendrán sucesivamente los nombres <tt>lvol0</tt>, <tt>lvol1</tt>...
            </li>
            <li>Crear un sistema de ficheros en el LV.
            </li>
            <li>Establecer que ese LV se monte en el directorio indicado cada vez que arranque la máquina.
            </li>
            <li>Realizar el montaje.
            </li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
  A continuación, se muestra un ejemplo de la ejecución de este mandato ilustrando cuál debe ser su comportamiento:
  <pre>fperez@ubuntu22:~/ASI/proyecto$ ls /mnt /mnt2 /mnt3
ls: no se puede acceder a '/mnt2': No existe el archivo o el directorio
ls: no se puede acceder a '/mnt3': No existe el archivo o el directorio
/mnt:
fperez@ubuntu22:~/ASI/proyecto$ sudo ./configurar_almacenamiento.sh VG3 2 /dev/sdb /dev/sdc 3 33 /mnt  33 /mnt2 34 /mnt3
fperez@ubuntu22:~/ASI/proyecto$ sudo lvs
  LV    VG  Attr       LSize  Pool Origin Data%  Meta%  Move Log Cpy%Sync Convert
  lvol0 VG3 -wi-ao---- 80,00m
  lvol1 VG3 -wi-ao---- 80,00m
  lvol2 VG3 -wi-ao---- 84,00m
fperez@ubuntu22:~/ASI/proyecto$ mount | grep \/mnt
/dev/mapper/VG3-lvol0 on /mnt type ext2 (rw,relatime)
/dev/mapper/VG3-lvol1 on /mnt2 type ext2 (rw,relatime)
/dev/mapper/VG3-lvol2 on /mnt3 type ext2 (rw,relatime)
</pre>

  <h2>Tercera fase</h2>
  El objetivo de esta fase es crear un <i>script</i> que realice la
  configuración de un servidor NFS acorde a los parámetros especificados
  que indican qué directorios se exportan, con qué permisos (<tt>rw</tt> o <tt>ro</tt>) y a qué máquinas.
  <p>
    El formato del mandato es el siguiente:
  </p>
  <pre>nfs_servidor.sh hosts_permitidos1 permisos1 directorio_exportado1 hosts_permitidos2 permisos2 directorio_exportado2......
</pre>
  Se va a considerar que, si en el argumento correspondiente a las
  máquinas a las que se les permite importar un directorio aparece un 0,
  se estará solicitando habilitar acceso universal a ese directorio.
  <p>
    El <i>script</i> no debe escribir nada por la salida estándar.
  </p>
  <p>
    La funcionalidad del <i>script</i> es la siguiente:
  </p>
  <ul>
    <li>Como se explicó previamente, se debe realizar un control de errores
      antes de realizar ninguna operación. En ese control se deben verificar
      las siguientes condiciones de error que provocarán que el <i>script</i> termine inmediatamente retornando un
      código de error:
      <ul>
        <li>Se debe estar ejecutando como superusuario (recuerde que, como se indicó previamente, se debe ejecutar con
          <tt>sudo</tt>), devolviendo un 1 en caso contrario. Esa comprobación ya está incluida en el <i>script</i>
          proporcionado como material de apoyo.
        </li>
        <li>El número de argumentos debe de ser correcto (múltiplo de 3) y los permisos especificados deben corresponder
          a los valores <tt>rw</tt> o <tt>ro</tt>, devolviendo un 2 en caso contrario.
        </li>
        <li>Se debe comprobar que los directorios exportados existen, retornando un error con valor 3 en caso contrario.
        </li>
      </ul>
    </li>
    <li>Una vez comprobado que no existen errores <i>a priori</i>, se procede a implementar la funcionalidad del
      <i>script</i>:
      <ul>
        <li>En primer lugar, hay que asegurarse de tener instalado el paquete que contiene la funcionalidad de servidor
          de NFS.
        </li>
        <li>A continuación, por cada directorio exportado, se debe añadir
          la línea correspondiente al fichero donde se definen las exportaciones,
          tratando el caso especial de que aparezca un 0 en el campo
          correspondiente a los equipos permitidos, que implica un acceso
          universal. Solo es necesario que se especifique los permisos: las demás
          opciones pueden tomar los valores por defecto.
        </li>
        <li>Por último, hay que ejecutar adecuadamente el mandato <tt>exportfs</tt> para actualizarlas.
        </li>
      </ul>
    </li>
  </ul>
  A continuación, se muestra un ejemplo de la ejecución de este mandato ilustrando cuál debe ser su comportamiento:
  <pre>fperez@ubuntu22:~/ASI/proyecto$ sudo ./nfs_servidor.sh 10.0.2.0/24 rw /srv 0 ro /mnt
fperez@ubuntu22:~/ASI/proyecto$ sudo exportfs -v # con los permisos especificados y las opciones por defecto
/srv          	10.0.2.0/24(sync,wdelay,hide,no_subtree_check,sec=sys,rw,secure,root_squash,no_all_squash)
/mnt          	&lt;world&gt;(sync,wdelay,hide,no_subtree_check,sec=sys,ro,secure,root_squash,no_all_squash)
</pre>

  <h2>Cuarta fase</h2>
  El objetivo de esta fase es crear un <i>script</i> que realice la
  configuración de un cliente NFS acorde a los parámetros especificados
  que indican qué directorios se importan, de qué servidores y en qué
  directorios locales se montan.
  <p>
    El formato del mandato es el siguiente:
  </p>
  <pre>nfs_cliente.sh servidor1 directorio_importado1 directorio_montaje1 servidor2 directorio_importado2 directorio_montaje2...
</pre>
  <p>
    El <i>script</i> no debe escribir nada por la salida estándar.
  </p>
  <p>
    Nótese que este es el primer <i>script</i> cuyo resultado depende del estado de otro nodo. No se va a permitir que
    este <i>script</i> ejecute operaciones sobre el nodo remoto con <tt>ssh</tt> para evitar relaciones complejas entre
    las máquinas (téngase en cuenta que, si permitimos que este <i>script</i> haga un <tt>ssh</tt> sobre el nodo que
    actúa de servidor NFS, al abordar la última fase tendríamos una relación de tres: el nodo maestro realiza un
    <tt>ssh</tt> al nodo cliente NFS que, a su vez, lleva a cabo un <tt>ssh</tt> al nodo servidor NFS).
  </p>
  <p>
    La funcionalidad del <i>script</i> es la siguiente:
  </p>
  <ul>
    <li>En este <i>script</i>, solo se puede realizar un control de errores anticipado para condiciones locales:
      <ul>
        <li>Se debe estar ejecutando como superusuario (recuerde que, como se indicó previamente, se debe ejecutar con
          <tt>sudo</tt>), devolviendo un 1 en caso contrario. Esa comprobación ya está incluida en el <i>script</i>
          proporcionado como material de apoyo.
        </li>
        <li>El número de argumentos debe de ser correcto (múltiplo de 3), devolviendo un 2 en caso contrario.
        </li>
        <li>Hay que asegurarse de que los directorios de montaje o bien no
          existen, en cuyo caso habrá que crearlos más adelante, o bien existen y
          son directorios, devolviendo un 3 en caso contrario.
        </li>
      </ul>
    </li>
    <li>Puede producirse un error si el equipo especificado (el
      servidor NFS) no está accesible o no exporta al cliente el directorio
      especificado. En este caso, no se realiza una estrategia anticipada,
      sino que se detectará en el propio mandato <tt>mount</tt>, evitando cualquier cambio de estado vinculado con ese
      directorio importado y terminando el <i>script</i> con un valor de retorno 4 sin procesar el resto de los
      directorios importados.
    </li>
    <li>Con respecto a la funcionalidad del <i>script</i>:
      <ul>
        <li>En primer lugar, hay que asegurarse de tener instalado el paquete que contiene la funcionalidad de cliente
          de NFS.
        </li>
        <li>A continuación, por cada directorio importado, debe
          establecerse que se monte sobre el directorio local especificado, que se
          creará si no existe, el directorio remoto indicado cada vez que
          arranque la máquina y, además, realizar el montaje. Recuerde que es en
          ese punto donde se detectarán los errores vinculados con el nodo remoto.
        </li>
      </ul>
    </li>
  </ul>
  A continuación, se muestra un ejemplo de la ejecución de este mandato
  ilustrando cuál debe ser su comportamiento. Nótese que en este caso hay
  dos máquinas involucradas en la prueba, estando la máquina 10.0.2.4
  configurada como servidor NFS siguiendo el ejemplo mostrado en la fase
  previa.
  <pre>ls /mnt /mnt4
ls: no se puede acceder a '/mnt4': No existe el archivo o el directorio
/mnt:
fperez@ubuntu22:~/ASI/proyecto$ sudo ./nfs_cliente.sh 10.0.2.4 /srv /mnt 10.0.2.4 /mnt /mnt4
fperez@ubuntu22:~/ASI/proyecto$ mount | grep \/mnt
10.0.2.4:/srv on /mnt type nfs4 (rw,relatime,vers=4.2,rsize=262144,wsize=262144,namlen=255,hard,proto=tcp,timeo=600,retrans=2,sec=sys,clientaddr=10.0.2.15,local_lock=none,addr=10.0.2.4)
10.0.2.4:/mnt on /mnt4 type nfs4 (rw,relatime,vers=4.2,rsize=262144,wsize=262144,namlen=255,hard,proto=tcp,timeo=600,retrans=2,sec=sys,clientaddr=10.0.2.15,local_lock=none,addr=10.0.2.4)
</pre>

  <h2>Quinta fase</h2>
  Esta fase es la culminación del proyecto creando un rudimento de una
  herramienta de automatización de la administración, que, de manera
  similar a Ansible, tenga un modo de operación con un nodo maestro de
  control que va copiando (<tt>scp</tt>) a los nodos gestionados (al directorio <tt>/tmp</tt> de cada nodo remoto) y
  ejecutando de forma remota (<tt>ssh</tt>) los <i>scripts</i>
  de configuración especificados. Recuerde que para probar esta fase se
  requieren, al menos, dos equipos configurados previamente para que
  puedan trabajar con <tt>ssh</tt> sin contraseñas.
  <p>
    Nótese que se proporciona un <i>script</i> de configuración muy sencillo (<tt>kernel_log.sh</tt>) para depurar esta
    fase e incluso poder realizarla sin haber hecho las fases previas.
  </p>
  <p>
    El formato del mandato es el siguiente:
  </p>
  <pre>maestro.sh fich_config
</pre>
  El formato del fichero de configuración es el que se muestra a continuación:
  <pre># comentario y a continuación una línea en blanco

NOMBRE_PRUEBA1 HOST1 FICH_SALIDA1 MANDATO1 ARG1 ARG2...
NOMBRE_PRUEBA2 HOST2 FICH_SALIDA2 MANDATO2 ARG1 ARG2...
</pre>
  Por ejemplo:
  <pre># máquina apagada
KERNEL_LOG 10.0.2.33 /tmp/kerlog-33.txt kernel_log.sh 12

# no pasa parámetro
KERNEL_LOG 10.0.2.4 /tmp/kerlog-4.txt kernel_log.sh

# OK
KERNEL_LOG 10.0.2.4 /tmp/kerlog-4.txt kernel_log.sh 15

    # OK
KERNEL_LOG 10.0.2.15 /tmp/kerlog-15.txt kernel_log.sh 10
</pre>
  Con respecto a la salida estándar, debe tener el siguiente formato:
  <pre>EJECUTANDO NOMBRE_PRUEBA1 EN HOST1
RESULTADO RES SALIDA EN FICH_SALIDA1
EJECUTANDO NOMBRE_PRUEBA2 EN HOST2
RESULTADO RES SALIDA EN FICH_SALIDA2
.....................................
</pre>
  donde <tt>RES</tt> puede ser: <tt>OK</tt>, <tt>UNREACHABLE</tt> o <tt>ERROR=N</tt> siendo <tt>N</tt> el valor distinto
  de 0 devuelto por el <i>script</i> de configuración.
  <p>
    Este es el resultado para el ejemplo planteado:
  </p>
  <pre>EJECUTANDO KERNEL_LOG EN 10.0.2.33
RESULTADO UNREACHABLE SALIDA EN /tmp/kerlog-33.txt
EJECUTANDO KERNEL_LOG EN 10.0.2.4
RESULTADO ERROR=2 SALIDA EN /tmp/kerlog-4.txt
EJECUTANDO KERNEL_LOG EN 10.0.2.4
RESULTADO OK SALIDA EN /tmp/kerlog-4.txt
EJECUTANDO KERNEL_LOG EN 10.0.2.15
RESULTADO OK SALIDA EN /tmp/kerlog-15.txt
</pre>
  La funcionalidad del <i>script</i> es la siguiente:
  <ul>
    <li>Se ejecutará sin <tt>sudo</tt> en el nodo maestro de control, pero en la cuenta que está asociada a
      <tt>sudo</tt> en los nodos remotos.
    </li>
    <li>Sí usará <tt>sudo</tt> para ejecutar el mandato remoto:
      <pre># la opción -n impide que ssh lea la entrada estándar
ssh -n $HOST sudo ...
</pre>
    </li>
    <li>Copiará los sucesivos <i>scripts</i> de configuración en el directorio <tt>/tmp</tt> de la máquina remota, no
      siendo necesario borrar ese fichero remoto al concluir la ejecución de ese <i>script</i> (seguimos con la política
      de evitar acciones destructivas <i>por si las moscas</i>).
    </li>
    <li>Con respecto al control de errores en la línea de mandatos,
      debe verificarse que se recibe un único argumento y que este es un
      fichero regular que el usuario puede leer. En caso contrario, el <i>script</i> debe terminar devolviendo un 1.
    </li>
    <li>En cuanto el control de errores en el procesado del fichero de
      configuración, si hay un error en la especificación de una línea, se
      mostrará un mensaje de error por la salida de error y se pasará a
      procesar la siguiente línea (el <i>script</i> continuará y seguirá terminando con un valor 0). Nótese que en caso
      de error no debería ejecutarse el <tt>scp</tt> ni aparecer en la salida <tt>EJECUTANDO...</tt>. Hay que controlar
      los siguientes errores:
      <ul>
        <li>Una línea debe incluir el número de campos pertinente.
        </li>
        <li>Debe existir y ser accesible el fichero especificado como mandato.
        </li>
        <li>El fichero indicado para recoger la salida, en caso de existir, debería ser modificable por el usuario (por
          ejemplo, <tt>/etc/passwd</tt> no lo sería) que ejecuta el <i>script</i> maestro (recuerde que se ejecuta sin
          <tt>sudo</tt>) pero no ser un directorio (por ejemplo, <tt>/tmp</tt>). En caso de no existir, debería
          comprobarse que el usuario puede crearlo y, en caso negativo (por ejemplo, <tt>/noexiste</tt>), no realizar el
          <tt>scp</tt>, imprimir el mensaje de error y pasar a la siguiente línea.
        </li>
        <li>Recuerde que no se consideran como error las líneas vacías (o
          llenas de espacios y/o tabuladores) ni aquellas cuyo primer carácter
          distinto del espacio sea un <tt>#</tt>.
        </li>
      </ul>
    </li>
    <li>Por lo que se refiere al procesado de una línea válida, requerirá la copia del mandato al directorio
      <tt>/tmp</tt>
      remoto. A continuación, si no ha habido un error, se ejecutará el
      mandato remoto recogiendo su salida estándar y su estado de terminación.
      Por último, se imprimirá el resumen del resultado diferenciando entre <tt>UNREACHABLE</tt>, si falló el
      <tt>scp</tt> o el <tt>ssh</tt> devolvió el valor 255, <tt>OK</tt>, en caso de que el <i>script</i> remoto termine
      satisfactoriamente, o <tt>ERROR=N</tt>, si terminó con un valor distinto de 0.
    </li>
  </ul>
  A continuación, se muestra un ejemplo de fichero de configuración:

  <pre># máquina apagada
KERNEL_LOG 10.0.2.33 /tmp/kerlog-33.txt kernel_log.sh
# no pasa parámetro
KERNEL_LOG 10.0.2.4 /tmp/kerlog-4.txt kernel_log.sh
KERNEL_LOG 10.0.2.4 /tmp/kerlog-4.txt kernel_log.sh 15
KERNEL_LOG 10.0.2.15 /tmp/kerlog-15.txt kernel_log.sh 10

CREA_USUARIOS 10.0.2.4 /tmp/usu_contra-4 crear_usuarios.sh new-project user1 user2 user3
CREA_USUARIOS 10.0.2.15 /tmp/usu_contra-15 crear_usuarios.sh new-project user1 user2 user3

CREA_ALMACENAMIENTO 10.0.2.15 /dev/null configurar_almacenamiento.sh VG3 2 /dev/sdb /dev/sdc 3 33 /mnt  33 /mnt2 34 /mnt3

NFS_SRV 10.0.2.4 /dev/null nfs_servidor.sh 10.0.2.0/24 rw /srv 0 ro /mnt
NFS_CLNT 10.0.2.15 /dev/null nfs_cliente.sh 10.0.2.4 /srv /mnt 10.0.2.4 /mnt /mnt4
</pre>
  El resultado debería ser el siguiente:
  <pre>EJECUTANDO KERNEL_LOG EN 10.0.2.33
RESULTADO UNREACHABLE SALIDA EN /tmp/kerlog-33.txt
EJECUTANDO KERNEL_LOG EN 10.0.2.4
RESULTADO ERROR=2 SALIDA EN /tmp/kerlog-4.txt
EJECUTANDO KERNEL_LOG EN 10.0.2.4
RESULTADO OK SALIDA EN /tmp/kerlog-4.txt
EJECUTANDO KERNEL_LOG EN 10.0.2.15
RESULTADO OK SALIDA EN /tmp/kerlog-15.txt
EJECUTANDO CREA_USUARIOS EN 10.0.2.4
RESULTADO OK SALIDA EN /tmp/usu_contra-4
EJECUTANDO CREA_USUARIOS EN 10.0.2.15
RESULTADO OK SALIDA EN /tmp/usu_contra-15
EJECUTANDO CREA_ALMACENAMIENTO EN 10.0.2.15
RESULTADO OK SALIDA EN /dev/null
EJECUTANDO NFS_SRV EN 10.0.2.4
RESULTADO OK SALIDA EN /dev/null
EJECUTANDO NFS_CLNT EN 10.0.2.15
RESULTADO OK SALIDA EN /dev/null
</pre>

  <h2>Entrega de la práctica</h2>
  El plazo se extiende hasta el final del <b>16 de enero de 2023</b>. Se realizará en la máquina triqui, usando el
  mandato:
  <pre>entrega.asi proyecto.2023
</pre>
  Este mandato recogerá los siguientes ficheros:
  <ul>
    <li><tt>autores</tt>: Fichero con los datos de los autores:
      <pre>DNI APELLIDOS NOMBRE MATRÍCULA
</pre>
    </li>
    <li><tt>memoria.txt</tt>: Memoria de la práctica. En ella, puede exponer los comentarios personales que considere
      oportuno.
    </li>
    <li><tt>crear_usuarios.sh</tt>.
    </li>
    <li><tt>configurar_almacenamiento.sh</tt>.
    </li>
    <li><tt>nfs_servidor.sh</tt>.
    </li>
    <li><tt>nfs_cliente.sh</tt>.
    </li>
    <li><tt>maestro.sh</tt>.
    </li>
  </ul>


</body>

</html>